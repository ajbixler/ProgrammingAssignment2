# There are two primary functions in this assignment.  The first function, 
#makeCacheMatrix(),  does most of the work.  It is a constructor function, 
#like the ones described in the videos from week 2.  It builds a list, where 
#each element of the list is a function.  For example if I call the function 
#with this code:

#tm1<-rnorm(25,5,1)             #make a 5x5 matrix of random variables  
#dim(tm1)<-c(5,5)               #this produces a solvable matrix
#tf1<-makeCacheMatrix(tm1)      #call the function with matrix tm1 as an input 
#                               #and tf1 as the funtion output

#All of those "list functions" (tf1$get(), tf1$set(), tf1$getinv(), and tf1$setinv() for
#the example code above) created by makeCacheMatrix() share 
#a common environment. Variables like the matrix that is assigned to it (e.g. tm1) and, 
#later, the cached inverse matrix, reside in that shared environment. 
#And the functions look for free variables there.


makeCacheMatrix <- function(x = matrix()) {
        s <- NULL               #s starts out NULL
        set <- function(y) {    #first function
                x <<- y         #passes matrix to function parent environment
                s <<- NULL      #resets s in the parent environment
        }
        get <- function() x     #calls matrix from parent environment
        setinv <- function(solve) s <<- solve   #cacheSolve uses this to return 
                                                #inverted matrix to this fn's 
                                                #parent environment
        getinv <- function() s  #calls inverted matrix from parent environment
        list(set = set, get = get, #defines the structure of makeCacheMatrix()
             setinv = setinv,      #output as a list of functions
             getinv = getinv)
}


## cacheSolve() is not a part of the constructor function and returns
#it's value to the global environment. But it works by calling the "list functions"
#generated by makeCacheMatrix(), tf1$getinv() for example.  When it calls those
#"list functions" they access the shared environment (aka list environmet or parent
#environment of list functions) to read the matrix and to store the inverted matrix.

cacheSolve <- function(x, ...) {        
        s <- x$getinv()         #calls getinv(), which returns NULL or previous cache
        if(!is.null(s)) {       #if s has been updated - isn't null - then it
                message("getting inverted matrix") #returns a message
                return(s)       #and returns the stored inverted matrix
        }
        data <- x$get()         #otherwise it pulls the matrix
        s <- solve(data, ...)   #inverts it
        x$setinv(s)             #and writes it into the list environment
        s                       #and returns the value to the working environment too
}
